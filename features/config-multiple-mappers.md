## Configuration

### Multiple mappers

In a package usually a single mapper is enough for most use cases. You can config multiple
mapper in different modes with different names.

Let set up an empty golang project without any dependency.

```go.mod
module github.com/toniphan21/go-mapper-gen/multimappers

go 1.25
```

Given that you have 2 simple structs

```go
// file: code.go
//go:generate go run github.com/toniphan21/go-mapper-gen/cmd/generator

package multimappers

type User struct {
	ID    string
	Name  string
	Email string
	Age   int
}

type UserEntity struct {
	ID    string
	Name  string
	Email string
}

```

Using `priorities { [0] {...} [1] {...} }` allows configuring multiple mappers
within the same package. The priority number determines the configuration
order: lower numbers are generated first (e.g. `0` is generated before `1`).

Configuration defined outside the `priorities {}` block represents the
default mapper and is always generated last.

```pkl
packages {
	["github.com/toniphan21/go-mapper-gen/multimappers"] {
		priorities {
			[0] {
				// despite that the mapper maps same structs, each one can be config different way
				source_pkg = "{CurrentPackage}"
				decorator_mode = "never"
				generate_go_doc = false

				structs {
					["User"] { source_struct_name = "UserEntity" }
				}
			}

			[1] {
				// despite that the mapper maps same structs, each one can be config different way
				source_pkg = "{CurrentPackage}"
				interface_name = "Mapper"
				constructor_name = "NewMapper"
				implementation_name = "mapperImpl"
				decorator_interface_name = "MapperDecorator"
				decorator_noop_name = "MapperDecoratorNoOp"
				decorator_mode = "always"
				
				structs {
					["User"] { source_struct_name = "UserEntity" }
				}
			}
		}

		// outside of priority, it's "default" config and always has last priority
		mode = "functions"
		source_pkg = "{CurrentPackage}"

		structs {
			["User"] { source_struct_name = "UserEntity" }
		}
	}
}
```

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package multimappers

type iMapper interface {
	ToUser(in UserEntity) User

	FromUser(in User) UserEntity
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToUser(in UserEntity) User {
	var out User

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	// Fields that could not be mapped:
	// out.Age =

	return out
}

func (m *iMapperImpl) FromUser(in User) UserEntity {
	var out UserEntity

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	return out
}

var _ iMapper = (*iMapperImpl)(nil)

type Mapper interface {
	// ToUser converts a UserEntity value into a User value.
	ToUser(in UserEntity) User

	// FromUser converts a User value into a UserEntity value.
	FromUser(in User) UserEntity
}

type MapperDecorator interface {
	decorateToUser(in *UserEntity, out *User)

	decorateFromUser(in *User, out *UserEntity)
}

func NewMapper(decorator MapperDecorator) Mapper {
	return &mapperImpl{decorator: decorator}
}

type mapperImpl struct {
	decorator MapperDecorator
}

func (m *mapperImpl) ToUser(in UserEntity) User {
	var out User

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	if m.decorator != nil {
		m.decorator.decorateToUser(&in, &out)
	}

	return out
}

func (m *mapperImpl) FromUser(in User) UserEntity {
	var out UserEntity

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	if m.decorator != nil {
		m.decorator.decorateFromUser(&in, &out)
	}

	return out
}

type MapperDecoratorNoOp struct{}

func (d *MapperDecoratorNoOp) decorateToUser(in *UserEntity, out *User) {
	// Fields that could not be mapped:
	// out.Age =
}

func (d *MapperDecoratorNoOp) decorateFromUser(in *User, out *UserEntity) {}

var _ Mapper = (*mapperImpl)(nil)
var _ MapperDecorator = (*MapperDecoratorNoOp)(nil)

// ToUser converts a UserEntity value into a User value.
func ToUser(in UserEntity, decorators ...func(*UserEntity, *User)) User {
	var out User

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	// Fields that could not be mapped:
	// out.Age =

	for _, decorate := range decorators {
		decorate(&in, &out)
	}

	return out
}

// FromUser converts a User value into a UserEntity value.
func FromUser(in User) UserEntity {
	var out UserEntity

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	return out
}
```

[//]: # (EmitCode:examples/config/01-multiple-mappers)
