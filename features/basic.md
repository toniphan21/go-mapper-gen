## Basic

Firstly, let set up an empty golang project without any dependency.

```go.mod
module github.com/toniphan21/go-mapper-gen/basic

go 1.25
```

### Structs in the same package

Given that you have 2 structs in your source code:

```go
// file: code.go
//go:generate go run github.com/toniphan21/go-mapper-gen/cmd/generator

package basic

type User struct {
	ID    string
	Name  string
	Email string
	Age   int
}

type UserEntity struct {
	ID    string
	Name  string
	Email string
	Age   int
}
```

#### Minimal configuration

`go-mapper-generator` is using a `pkl` file for configuration. This is minimal
config to generate a mapper from `User` to `UserEntity` struct:

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/basic"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["User"] { source_struct_name = "UserEntity" }
    }
  }
}
```

Expected code generated in `gen_mapper.go` is:

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package basic

type iMapper interface {
	// ToUser converts a UserEntity value into a User value.
	ToUser(in UserEntity) User

	// FromUser converts a User value into a UserEntity value.
	FromUser(in User) UserEntity
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToUser(in UserEntity) User {
	var out User

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email
	out.Age = in.Age

	return out
}

func (m *iMapperImpl) FromUser(in User) UserEntity {
	var out UserEntity

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email
	out.Age = in.Age

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:examples/basic/01-minimal-config)

#### mode types: emit interface, implementation and constructor

By default, generator use mode `"types"` which emits an interface `iMapper`, 
an implementation `iMapperImpl` and the constructor `new_iMapper`. They are unexported
because `go-mapper-gen` doesn't want to pollute your package. You can compose in
your public interface like this:

```go
package basic

type YourInterface interface {
	iMapper
}
```

or simply you can rename the generated interface by using interface_name configuration:

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/basic"] {
    interface_name = "Mapper"
    implementation_name = "mapperImpl"
    constructor_name = "NewMapper"
    
    source_pkg = "{CurrentPackage}"

    structs {
      ["User"] { source_struct_name = "UserEntity" }
    }
  }
}
```

the expected generated code is:

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package basic

type Mapper interface {
	// ToUser converts a UserEntity value into a User value.
	ToUser(in UserEntity) User

	// FromUser converts a User value into a UserEntity value.
	FromUser(in User) UserEntity
}

func NewMapper() Mapper {
	return &mapperImpl{}
}

type mapperImpl struct{}

func (m *mapperImpl) ToUser(in UserEntity) User {
	var out User

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email
	out.Age = in.Age

	return out
}

func (m *mapperImpl) FromUser(in User) UserEntity {
	var out UserEntity

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email
	out.Age = in.Age

	return out
}

var _ Mapper = (*mapperImpl)(nil)
```

[//]: # (EmitCode:examples/basic/02-emit-interface-implementation-constructor)

#### mode functions: emit package level functions

You can change the mode to `"functions"`
```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/basic"] {
    mode = "functions"

    // simply ignored in mode "functions", can be deleted
    interface_name = "Mapper"
    implementation_name = "mapperImpl"
    constructor_name = "NewMapper"
    
    source_pkg = "{CurrentPackage}"

    structs {
      ["User"] { source_struct_name = "UserEntity" }
    }
  }
}
```

the configuration will generate package level functions only

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package basic

// ToUser converts a UserEntity value into a User value.
func ToUser(in UserEntity) User {
	var out User

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email
	out.Age = in.Age

	return out
}

// FromUser converts a User value into a UserEntity value.
func FromUser(in User) UserEntity {
	var out UserEntity

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email
	out.Age = in.Age

	return out
}
```

[//]: # (EmitCode:examples/basic/03-emit-package-functions)

### Structs in other package

In real project, you rarely want to map structs in the same package.
The mapper is usually used to cross boundaries.

Let say you have a struct in root (which is your Business Domain layer):

```go

```

### Structs with missing fields

When you convert 2 structs which is not fully identical such as missing a field,
the generator will generate a "decorator" which allow you to fill the missing fields easily.

```go
// file: code.go
//go:generate go run github.com/toniphan21/go-mapper-gen/cmd/generator

package basic

type User struct {
	ID    string
	Name  string
	Email string
	Age   int
}

type UserEntity struct {
	ID    string
	Name  string
	Email string
}
```

#### mode "types"

In mode "types", generator will create a Decorator interface which you can control the name
via `decorator_interface_name` (default is `iMapperDecorator`)

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/basic"] {
    source_pkg = "{CurrentPackage}"
    
    // decorator_interface_name = "customMapperDecoratorName"
    // decorator_noop_name = "" // if empty the NoOp implementation will be omitted
    
    structs {
      ["User"] { source_struct_name = "UserEntity" }
    }
  }
}
```

Generated code
```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package basic

type iMapper interface {
	// ToUser converts a UserEntity value into a User value.
	ToUser(in UserEntity) User

	// FromUser converts a User value into a UserEntity value.
	FromUser(in User) UserEntity
}

type iMapperDecorator interface {
	decorateToUser(in *UserEntity, out *User)

	decorateFromUser(in *User, out *UserEntity)
}

func new_iMapper(decorator iMapperDecorator) iMapper {
	return &iMapperImpl{decorator: decorator}
}

type iMapperImpl struct {
	decorator iMapperDecorator
}

func (m *iMapperImpl) ToUser(in UserEntity) User {
	var out User

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	if m.decorator != nil {
		m.decorator.decorateToUser(&in, &out)
	}

	return out
}

func (m *iMapperImpl) FromUser(in User) UserEntity {
	var out UserEntity

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	return out
}

type iMapperDecoratorNoOp struct{}

func (d *iMapperDecoratorNoOp) decorateToUser(in *UserEntity, out *User) {
	// Fields that could not be mapped:
	// out.Age =
}

func (d *iMapperDecoratorNoOp) decorateFromUser(in *User, out *UserEntity) {}

var _ iMapper = (*iMapperImpl)(nil)
var _ iMapperDecorator = (*iMapperDecoratorNoOp)(nil)
```

The generator also generated a NoOp implementation which you can use to combine
or simply notice the missing/unconvertible fields.

You can disable the NoOpDecorator by setting `decorator_noop_name` to empty

#### mode "functions"

In mode "functions", the generator will not generate an Decorator interface, rather
add an optional decorator func so you can modify in functional style.

Configuration file:
```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/basic"] {
    mode = "functions"
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["User"] { source_struct_name = "UserEntity" }
    }
  }
}
```

Generated code:

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package basic

// ToUser converts a UserEntity value into a User value.
func ToUser(in UserEntity, decorators ...func(*UserEntity, *User)) User {
	var out User

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	// Fields that could not be mapped:
	// out.Age =

	for _, decorate := range decorators {
		decorate(&in, &out)
	}

	return out
}

// FromUser converts a User value into a UserEntity value.
func FromUser(in User) UserEntity {
	var out UserEntity

	out.ID = in.ID
	out.Name = in.Name
	out.Email = in.Email

	return out
}
```

