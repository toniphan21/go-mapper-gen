## Numeric Converter

There is a built-in converter which convert between the numeric types (except `complex`).
It simply casts between numeric type without checking overflow or signed.

First set up an empty golang project without any dependency.

```go.mod
module github.com/toniphan21/go-mapper-gen/numeric

go 1.25
```

The numeric converter is a built-in converter, it works with minimal configuration:

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/numeric"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Target"] { source_struct_name = "Source" }
    }
  }
}
```

### features

The converter can:

- convert a numeric type to other via casting, ie: `byte -> int` via int(...)
- convert a type to numeric by other converter before apply the casting, ie: `*byte -> int` via int(*v)
- convert a type to numeric via casting then convert to a type by other converter, ie: `byte -> *int` via &int(v)

```go
// file: code.go
//go:generate go run github.com/toniphan21/go-mapper-gen/cmd/generator

package numeric

type Target struct {
	A int
	B int
	C *int
	D *int
}

type Source struct {
	A uint
	B *uint
	C uint
	D *uint
}
```

the generated source code is:

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package numeric

type iMapper interface {
	// ToTarget converts a Source value into a Target value.
	ToTarget(in Source) Target

	// FromTarget converts a Target value into a Source value.
	FromTarget(in Target) Source
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToTarget(in Source) Target {
	var out Target

	out.A = int(in.A)

	var v0 uint
	if in.B != nil {
		v0 = *in.B
	}
	out.B = int(v0)
	v1 := int(in.C)
	out.C = &v1

	var v2 uint
	if in.D != nil {
		v2 = *in.D
	}
	v3 := int(v2)
	out.D = &v3

	return out
}

func (m *iMapperImpl) FromTarget(in Target) Source {
	var out Source

	out.A = uint(in.A)
	v0 := uint(in.B)
	out.B = &v0

	var v1 int
	if in.C != nil {
		v1 = *in.C
	}
	out.C = uint(v1)

	var v2 int
	if in.D != nil {
		v2 = *in.D
	}
	v3 := uint(v2)
	out.D = &v3

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:testdata/golden/numeric/01-features)

### int

Given that you have a struct with all numeric type, the other one just have `int`

```go
// file: code.go
//go:generate go run github.com/toniphan21/go-mapper-gen/cmd/generator

package numeric

type Typed int
type Alias = int

type Target struct {
	A int
	B int
	C int
	D int
	E int
	F int
	G int
	H int
	I int
	J int
	K int
	L int
	M int
	N int
	O int
}

type Source struct {
	A byte
	B uint8
	C uint16
	D uint32
	E uint64
	F int8
	G int16
	H int32
	I int64
	J uint
	K int
	L float32
	M float64	
	N Typed
	O Alias
}
```

the generated source code is:

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package numeric

type iMapper interface {
	// ToTarget converts a Source value into a Target value.
	ToTarget(in Source) Target

	// FromTarget converts a Target value into a Source value.
	FromTarget(in Target) Source
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToTarget(in Source) Target {
	var out Target

	out.A = int(in.A)
	out.B = int(in.B)
	out.C = int(in.C)
	out.D = int(in.D)
	out.E = int(in.E)
	out.F = int(in.F)
	out.G = int(in.G)
	out.H = int(in.H)
	out.I = int(in.I)
	out.J = int(in.J)
	out.K = in.K
	out.L = int(in.L)
	out.M = int(in.M)
	out.N = int(in.N)
	out.O = in.O

	return out
}

func (m *iMapperImpl) FromTarget(in Target) Source {
	var out Source

	out.A = byte(in.A)
	out.B = uint8(in.B)
	out.C = uint16(in.C)
	out.D = uint32(in.D)
	out.E = uint64(in.E)
	out.F = int8(in.F)
	out.G = int16(in.G)
	out.H = int32(in.H)
	out.I = int64(in.I)
	out.J = uint(in.J)
	out.K = in.K
	out.L = float32(in.L)
	out.M = float64(in.M)
	out.N = Typed(in.N)
	out.O = in.O

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:testdata/golden/numeric/02-int)

### uint

Given that you have a struct with all numeric type, the other one just have `uint`

```go
// file: code.go
//go:generate go run github.com/toniphan21/go-mapper-gen/cmd/generator

package numeric

type Typed uint
type Alias = uint

type Target struct {
	A uint
	B uint
	C uint
	D uint
	E uint
	F uint
	G uint
	H uint
	I uint
	J uint
	K uint
	L uint
	M uint
	N uint
	O uint
}

type Source struct {
	A byte
	B uint8
	C uint16
	D uint32
	E uint64
	F int8
	G int16
	H int32
	I int64
	J uint
	K int
	L float32
	M float64	
	N Typed
	O Alias
}
```

the generated source code is:

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package numeric

type iMapper interface {
	// ToTarget converts a Source value into a Target value.
	ToTarget(in Source) Target

	// FromTarget converts a Target value into a Source value.
	FromTarget(in Target) Source
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToTarget(in Source) Target {
	var out Target

	out.A = uint(in.A)
	out.B = uint(in.B)
	out.C = uint(in.C)
	out.D = uint(in.D)
	out.E = uint(in.E)
	out.F = uint(in.F)
	out.G = uint(in.G)
	out.H = uint(in.H)
	out.I = uint(in.I)
	out.J = in.J
	out.K = uint(in.K)
	out.L = uint(in.L)
	out.M = uint(in.M)
	out.N = uint(in.N)
	out.O = in.O

	return out
}

func (m *iMapperImpl) FromTarget(in Target) Source {
	var out Source

	out.A = byte(in.A)
	out.B = uint8(in.B)
	out.C = uint16(in.C)
	out.D = uint32(in.D)
	out.E = uint64(in.E)
	out.F = int8(in.F)
	out.G = int16(in.G)
	out.H = int32(in.H)
	out.I = int64(in.I)
	out.J = in.J
	out.K = int(in.K)
	out.L = float32(in.L)
	out.M = float64(in.M)
	out.N = Typed(in.N)
	out.O = in.O

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:testdata/golden/numeric/03-uint)
