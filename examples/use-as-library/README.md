## Use go-mapper-gen as library

Given that you already have a project, first we need to add `go-mapper-gen` and `jennifer` as a dependency in `go.mod`

```go.mod
module github.com/toniphan21/awesome

go 1.25

require github.com/dave/jennifer v1.7.1
require github.com/toniphan21/go-mapper-gen v0.3.0
```

The `go.sum` is:

```go.sum
github.com/dave/jennifer v1.7.1 h1:B4jJJDHelWcDhlRQxWeo0Npa/pYKBLrirAQoTN45txo=
github.com/dave/jennifer v1.7.1/go.mod h1:nXbxhEmQfOZhWml3D1cDK5M1FLnMSozpbFN/m3RmGZc=
github.com/toniphan21/go-mapper-gen v0.3.0 h1:v59cRrNlgvZK7CZfsXYwABzo8o89Ko1ibbpDdfHBMGo=
github.com/toniphan21/go-mapper-gen v0.3.0/go.mod h1:xq9nD8FltQ5wLE81cEH/aXCukKNwA5//11LzamzLMEU=
```

Then set up a command to use as a generator

```go
// file: cmd/generator/main.go

package main

import (
	"go/types"
	"log/slog"
	"os"

	"github.com/dave/jennifer/jen"
	gen "github.com/toniphan21/go-mapper-gen"
	gencli "github.com/toniphan21/go-mapper-gen/pkg/cli"
)

func main() {
	// you need to handle args and create a slog.Logger instance, otherwise go-mapper-gen will use default one.
	// ...
	// ...

	wd, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	err = gencli.Run(gencli.RunCommand{
		// required, working directory
		WorkingDir: wd,

		// optional, config file name, default: mapper.pkl
		// ConfigFileName: "config.pkl",

		// optional, default: false
		// DryRun: false,

		// optional, default false
		PrintRegisteredConverters: true,

		// optional, if nil use DefaultParser
		// Parser: nil,

		// optional, if nil use DefaultFileManager
		// FileManager: nil,

		// optional, if nil use slog.DefaultLogger
		// Logger: nil

		// optional
		RegisterConverters: func() {
			// you can register your Converters here
			gen.RegisterConverter(&awesomeConverter{})
			slog.Info("registered awesome converter")
		},
	})

	if err != nil {
		// handle error
	}
}

type awesomeConverter struct{}

func (c *awesomeConverter) Init(parser gen.Parser, config gen.Config) {
	// no-op
}

func (c *awesomeConverter) Info() gen.ConverterInfo {
	return gen.ConverterInfo{
		Name:                 "MyAwesomeConverter",
		ShortForm:            "awesome -> legendary",
		ShortFormDescription: "convert awesome to legen... wait for it... dary!",
	}
}

func (c *awesomeConverter) CanConvert(ctx gen.LookupContext, targetType, sourceType types.Type) bool {
	// perform the check that it can convert sourceType to targetType
	return false
}

func (c *awesomeConverter) ConvertField(ctx gen.ConverterContext, target, source gen.Symbol, opts gen.ConverterOption) jen.Code {
	// generate your code here
	return nil
}

var _ gen.Converter = (*awesomeConverter)(nil)
```

Given that you have 2 structs in your code

```go
// file: code.go

package awesome

// you can add more converters and use your own binary to generate mapper now.
//go:generate go run ./cmd/generator

type Target struct {
	ID   string
	Name string
}

type Source struct {
	ID   string
	Name string
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/awesome"] {
    source_pkg = "{CurrentPackage}"

    structs {
      ["Target"] { source_struct_name = "Source" }
    }
  }
}
```

the generated code is:

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package awesome

type iMapper interface {
	// ToTarget converts a Source value into a Target value.
	ToTarget(in Source) Target

	// FromTarget converts a Target value into a Source value.
	FromTarget(in Target) Source
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToTarget(in Source) Target {
	var out Target

	out.ID = in.ID
	out.Name = in.Name

	return out
}

func (m *iMapperImpl) FromTarget(in Target) Source {
	var out Source

	out.ID = in.ID
	out.Name = in.Name

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```
