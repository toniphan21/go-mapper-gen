## pgtype numeric

First, let set up a project which use pgx v5 as library

```go.mod
module github.com/toniphan21/go-mapper-gen/example

go 1.25.1

require github.com/jackc/pgx/v5 v5.7.6
```

the `go.sum` file is

```go.sum
github.com/jackc/pgx/v5 v5.7.6 h1:rWQc5FwZSPX58r1OQmkuaNicxdmExaEz5A2DO2hUuTk=
github.com/jackc/pgx/v5 v5.7.6/go.mod h1:aruU7o91Tc2q2cFp5h4uP3f6ztExVpyVv88Xl/8Vl8M=
```

### pgtype.Timestamptz <-> *time.Time

Let set up 2 structs

```go
// file: code.go

package example

import "time"
import "github.com/jackc/pgx/v5/pgtype"

type Domain struct {
	A *time.Time
	B time.Time
}

type Database struct {
	A pgtype.Timestamptz
	B pgtype.Timestamptz
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/example"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Domain"] { source_struct_name = "Database" }
    }
  }
}
```

The generated code should be

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package example

import (
	pgtype "github.com/jackc/pgx/v5/pgtype"
	"time"
)

type iMapper interface {
	// ToDomain converts a Database value into a Domain value.
	ToDomain(in Database) Domain

	// FromDomain converts a Domain value into a Database value.
	FromDomain(in Domain) Database
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToDomain(in Database) Domain {
	var out Domain

	if in.A.Valid {
		out.A = &in.A.Time
	}

	var v0 *time.Time
	if in.B.Valid {
		v0 = &in.B.Time
	}
	if v0 != nil {
		out.B = *v0
	} else {
		var zero time.Time
		out.B = zero
	}

	return out
}

func (m *iMapperImpl) FromDomain(in Domain) Database {
	var out Database

	if in.A != nil {
		out.A = pgtype.Timestamptz{
			Time:  *in.A,
			Valid: true,
		}
	}

	var v0 *time.Time
	v0 = &in.B
	if v0 != nil {
		out.B = pgtype.Timestamptz{
			Time:  *v0,
			Valid: true,
		}
	}

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```
