## pgtype numeric

First, let set up a project which use pgx v5 as library

```go.mod
module github.com/toniphan21/go-mapper-gen/example

go 1.25.1

require github.com/jackc/pgx/v5 v5.7.6
```

the `go.sum` file is

```go.sum
github.com/jackc/pgx/v5 v5.7.6 h1:rWQc5FwZSPX58r1OQmkuaNicxdmExaEz5A2DO2hUuTk=
github.com/jackc/pgx/v5 v5.7.6/go.mod h1:aruU7o91Tc2q2cFp5h4uP3f6ztExVpyVv88Xl/8Vl8M=
```

### Int2 for nullable smallserial and smallint

when you have a `smallserial` or `smallint` column in your database, `sqlc` will
generate type `pgtype.Int2`, the golang equivalent type is `*int16`.

Let set up 2 structs

```go
// file: code.go

package example

import "github.com/jackc/pgx/v5/pgtype"

type Domain struct {
	A *int16
	B int16
	C int
}

type Database struct {
	A pgtype.Int2
	B pgtype.Int2
	C pgtype.Int2
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/example"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Domain"] { source_struct_name = "Database" }
    }
  }
}
```

The generated code should be

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package example

import pgtype "github.com/jackc/pgx/v5/pgtype"

type iMapper interface {
	// ToDomain converts a Database value into a Domain value.
	ToDomain(in Database) Domain

	// FromDomain converts a Domain value into a Database value.
	FromDomain(in Domain) Database
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToDomain(in Database) Domain {
	var out Domain

	if in.A.Valid {
		out.A = &in.A.Int16
	}

	var v0 *int16
	if in.B.Valid {
		v0 = &in.B.Int16
	}
	if v0 != nil {
		out.B = *v0
	} else {
		var zero int16
		out.B = zero
	}

	var v1 *int16
	if in.C.Valid {
		v1 = &in.C.Int16
	}

	var v2 int16
	if v1 != nil {
		v2 = *v1
	}
	out.C = int(v2)

	return out
}

func (m *iMapperImpl) FromDomain(in Domain) Database {
	var out Database

	if in.A != nil {
		out.A = pgtype.Int2{
			Int16: *in.A,
			Valid: true,
		}
	}

	var v0 *int16
	v0 = &in.B
	if v0 != nil {
		out.B = pgtype.Int2{
			Int16: *v0,
			Valid: true,
		}
	}

	var v1 *int16
	v2 := int16(in.C)
	v1 = &v2

	if v1 != nil {
		out.C = pgtype.Int2{
			Int16: *v1,
			Valid: true,
		}
	}

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:examples/sqlc/pgtype/02-int2)

### Int4 for nullable serial and integer

when you have a `serial` or `integer` column in your database, `sqlc` will
generate type `pgtype.Int4`, the golang equivalent type is `*int32`.

Let set up 2 structs

```go
// file: code.go

package example

import "github.com/jackc/pgx/v5/pgtype"

type Domain struct {
	A *int32
	B int32
	C int
}

type Database struct {
	A pgtype.Int4
	B pgtype.Int4
	C pgtype.Int4
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/example"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Domain"] { source_struct_name = "Database" }
    }
  }
}
```

The generated code should be

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package example

import pgtype "github.com/jackc/pgx/v5/pgtype"

type iMapper interface {
	// ToDomain converts a Database value into a Domain value.
	ToDomain(in Database) Domain

	// FromDomain converts a Domain value into a Database value.
	FromDomain(in Domain) Database
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToDomain(in Database) Domain {
	var out Domain

	if in.A.Valid {
		out.A = &in.A.Int32
	}

	var v0 *int32
	if in.B.Valid {
		v0 = &in.B.Int32
	}
	if v0 != nil {
		out.B = *v0
	} else {
		var zero int32
		out.B = zero
	}

	var v1 *int32
	if in.C.Valid {
		v1 = &in.C.Int32
	}

	var v2 int32
	if v1 != nil {
		v2 = *v1
	}
	out.C = int(v2)

	return out
}

func (m *iMapperImpl) FromDomain(in Domain) Database {
	var out Database

	if in.A != nil {
		out.A = pgtype.Int4{
			Int32: *in.A,
			Valid: true,
		}
	}

	var v0 *int32
	v0 = &in.B
	if v0 != nil {
		out.B = pgtype.Int4{
			Int32: *v0,
			Valid: true,
		}
	}

	var v1 *int32
	v2 := int32(in.C)
	v1 = &v2

	if v1 != nil {
		out.C = pgtype.Int4{
			Int32: *v1,
			Valid: true,
		}
	}

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:examples/sqlc/pgtype/03-int4)

### Int8 for nullable bigserial and bigint

when you have a `bigserial` or `bigint` column in your database, `sqlc` will
generate type `pgtype.Int8`, the golang equivalent type is `*int64`.

Let set up 2 structs

```go
// file: code.go

package example

import "github.com/jackc/pgx/v5/pgtype"

type Domain struct {
	A *int64
	B int64
	C int
}

type Database struct {
	A pgtype.Int8
	B pgtype.Int8
	C pgtype.Int8
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/example"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Domain"] { source_struct_name = "Database" }
    }
  }
}
```

The generated code should be

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package example

import pgtype "github.com/jackc/pgx/v5/pgtype"

type iMapper interface {
	// ToDomain converts a Database value into a Domain value.
	ToDomain(in Database) Domain

	// FromDomain converts a Domain value into a Database value.
	FromDomain(in Domain) Database
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToDomain(in Database) Domain {
	var out Domain

	if in.A.Valid {
		out.A = &in.A.Int64
	}

	var v0 *int64
	if in.B.Valid {
		v0 = &in.B.Int64
	}
	if v0 != nil {
		out.B = *v0
	} else {
		var zero int64
		out.B = zero
	}

	var v1 *int64
	if in.C.Valid {
		v1 = &in.C.Int64
	}

	var v2 int64
	if v1 != nil {
		v2 = *v1
	}
	out.C = int(v2)

	return out
}

func (m *iMapperImpl) FromDomain(in Domain) Database {
	var out Database

	if in.A != nil {
		out.A = pgtype.Int8{
			Int64: *in.A,
			Valid: true,
		}
	}

	var v0 *int64
	v0 = &in.B
	if v0 != nil {
		out.B = pgtype.Int8{
			Int64: *v0,
			Valid: true,
		}
	}

	var v1 *int64
	v2 := int64(in.C)
	v1 = &v2

	if v1 != nil {
		out.C = pgtype.Int8{
			Int64: *v1,
			Valid: true,
		}
	}

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:examples/sqlc/pgtype/04-int8)

### Float4 for nullable real

when you have a `real` column in your database, `sqlc` will generate type 
`pgtype.Float4`, the golang equivalent type is `*float32`.

Let set up 2 structs

```go
// file: code.go

package example

import "github.com/jackc/pgx/v5/pgtype"

type Domain struct {
	A *float32
	B float32
	C int
}

type Database struct {
	A pgtype.Float4
	B pgtype.Float4
	C pgtype.Float4
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/example"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Domain"] { source_struct_name = "Database" }
    }
  }
}
```

The generated code should be

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package example

import pgtype "github.com/jackc/pgx/v5/pgtype"

type iMapper interface {
	// ToDomain converts a Database value into a Domain value.
	ToDomain(in Database) Domain

	// FromDomain converts a Domain value into a Database value.
	FromDomain(in Domain) Database
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToDomain(in Database) Domain {
	var out Domain

	if in.A.Valid {
		out.A = &in.A.Float32
	}

	var v0 *float32
	if in.B.Valid {
		v0 = &in.B.Float32
	}
	if v0 != nil {
		out.B = *v0
	} else {
		var zero float32
		out.B = zero
	}

	var v1 *float32
	if in.C.Valid {
		v1 = &in.C.Float32
	}

	var v2 float32
	if v1 != nil {
		v2 = *v1
	}
	out.C = int(v2)

	return out
}

func (m *iMapperImpl) FromDomain(in Domain) Database {
	var out Database

	if in.A != nil {
		out.A = pgtype.Float4{
			Float32: *in.A,
			Valid:   true,
		}
	}

	var v0 *float32
	v0 = &in.B
	if v0 != nil {
		out.B = pgtype.Float4{
			Float32: *v0,
			Valid:   true,
		}
	}

	var v1 *float32
	v2 := float32(in.C)
	v1 = &v2

	if v1 != nil {
		out.C = pgtype.Float4{
			Float32: *v1,
			Valid:   true,
		}
	}

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:examples/sqlc/pgtype/05-float4)

### Float8 for nullable double precision

when you have a `double precision` column in your database, `sqlc` will generate type
`pgtype.Float8`, the golang equivalent type is `*float64`.

Let set up 2 structs

```go
// file: code.go

package example

import "github.com/jackc/pgx/v5/pgtype"

type Domain struct {
	A *float64
	B float64
	C int
}

type Database struct {
	A pgtype.Float8
	B pgtype.Float8
	C pgtype.Float8
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/example"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Domain"] { source_struct_name = "Database" }
    }
  }
}
```

The generated code should be

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package example

import pgtype "github.com/jackc/pgx/v5/pgtype"

type iMapper interface {
	// ToDomain converts a Database value into a Domain value.
	ToDomain(in Database) Domain

	// FromDomain converts a Domain value into a Database value.
	FromDomain(in Domain) Database
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToDomain(in Database) Domain {
	var out Domain

	if in.A.Valid {
		out.A = &in.A.Float64
	}

	var v0 *float64
	if in.B.Valid {
		v0 = &in.B.Float64
	}
	if v0 != nil {
		out.B = *v0
	} else {
		var zero float64
		out.B = zero
	}

	var v1 *float64
	if in.C.Valid {
		v1 = &in.C.Float64
	}

	var v2 float64
	if v1 != nil {
		v2 = *v1
	}
	out.C = int(v2)

	return out
}

func (m *iMapperImpl) FromDomain(in Domain) Database {
	var out Database

	if in.A != nil {
		out.A = pgtype.Float8{
			Float64: *in.A,
			Valid:   true,
		}
	}

	var v0 *float64
	v0 = &in.B
	if v0 != nil {
		out.B = pgtype.Float8{
			Float64: *v0,
			Valid:   true,
		}
	}

	var v1 *float64
	v2 := float64(in.C)
	v1 = &v2

	if v1 != nil {
		out.C = pgtype.Float8{
			Float64: *v1,
			Valid:   true,
		}
	}

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:examples/sqlc/pgtype/06-float8)

### Uint32 for xid

when you have a `xid` or `oid` column in your database, `sqlc` will generate type
`pgtype.Uint32`, the golang equivalent type is `*uint32`.

Let set up 2 structs

```go
// file: code.go

package example

import "github.com/jackc/pgx/v5/pgtype"

type Domain struct {
	A *uint32
	B uint32
	C int
}

type Database struct {
	A pgtype.Uint32
	B pgtype.Uint32
	C pgtype.Uint32
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/example"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Domain"] { source_struct_name = "Database" }
    }
  }
}
```

The generated code should be

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package example

import pgtype "github.com/jackc/pgx/v5/pgtype"

type iMapper interface {
	// ToDomain converts a Database value into a Domain value.
	ToDomain(in Database) Domain

	// FromDomain converts a Domain value into a Database value.
	FromDomain(in Domain) Database
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToDomain(in Database) Domain {
	var out Domain

	if in.A.Valid {
		out.A = &in.A.Uint32
	}

	var v0 *uint32
	if in.B.Valid {
		v0 = &in.B.Uint32
	}
	if v0 != nil {
		out.B = *v0
	} else {
		var zero uint32
		out.B = zero
	}

	var v1 *uint32
	if in.C.Valid {
		v1 = &in.C.Uint32
	}

	var v2 uint32
	if v1 != nil {
		v2 = *v1
	}
	out.C = int(v2)

	return out
}

func (m *iMapperImpl) FromDomain(in Domain) Database {
	var out Database

	if in.A != nil {
		out.A = pgtype.Uint32{
			Uint32: *in.A,
			Valid:  true,
		}
	}

	var v0 *uint32
	v0 = &in.B
	if v0 != nil {
		out.B = pgtype.Uint32{
			Uint32: *v0,
			Valid:  true,
		}
	}

	var v1 *uint32
	v2 := uint32(in.C)
	v1 = &v2

	if v1 != nil {
		out.C = pgtype.Uint32{
			Uint32: *v1,
			Valid:  true,
		}
	}

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:examples/sqlc/pgtype/07-uint32)

### Uint64 for xid8

when you have a `xid8` column in your database, `sqlc` will generate type
`pgtype.Uint64`, the golang equivalent type is `*uint64`.

Let set up 2 structs

```go
// file: code.go

package example

import "github.com/jackc/pgx/v5/pgtype"

type Domain struct {
	A *uint64
	B uint64
	C int
}

type Database struct {
	A pgtype.Uint64
	B pgtype.Uint64
	C pgtype.Uint64
}
```

With minimum configuration

```pkl
packages {
  ["github.com/toniphan21/go-mapper-gen/example"] {
    source_pkg = "{CurrentPackage}"
    
    structs {
      ["Domain"] { source_struct_name = "Database" }
    }
  }
}
```

The generated code should be

```go
// golden-file: gen_mapper.go
// Code generated by github.com/toniphan21/go-mapper-gen - test, DO NOT EDIT.

package example

import pgtype "github.com/jackc/pgx/v5/pgtype"

type iMapper interface {
	// ToDomain converts a Database value into a Domain value.
	ToDomain(in Database) Domain

	// FromDomain converts a Domain value into a Database value.
	FromDomain(in Domain) Database
}

func new_iMapper() iMapper {
	return &iMapperImpl{}
}

type iMapperImpl struct{}

func (m *iMapperImpl) ToDomain(in Database) Domain {
	var out Domain

	if in.A.Valid {
		out.A = &in.A.Uint64
	}

	var v0 *uint64
	if in.B.Valid {
		v0 = &in.B.Uint64
	}
	if v0 != nil {
		out.B = *v0
	} else {
		var zero uint64
		out.B = zero
	}

	var v1 *uint64
	if in.C.Valid {
		v1 = &in.C.Uint64
	}

	var v2 uint64
	if v1 != nil {
		v2 = *v1
	}
	out.C = int(v2)

	return out
}

func (m *iMapperImpl) FromDomain(in Domain) Database {
	var out Database

	if in.A != nil {
		out.A = pgtype.Uint64{
			Uint64: *in.A,
			Valid:  true,
		}
	}

	var v0 *uint64
	v0 = &in.B
	if v0 != nil {
		out.B = pgtype.Uint64{
			Uint64: *v0,
			Valid:  true,
		}
	}

	var v1 *uint64
	v2 := uint64(in.C)
	v1 = &v2

	if v1 != nil {
		out.C = pgtype.Uint64{
			Uint64: *v1,
			Valid:  true,
		}
	}

	return out
}

var _ iMapper = (*iMapperImpl)(nil)
```

[//]: # (EmitCode:examples/sqlc/pgtype/08-uint64)

